{"version":3,"sources":["components/Cell.tsx","components/Grid.tsx","utils/solver.ts","App.tsx","index.tsx"],"names":["Cell","props","useState","value","setValue","className","onChange","e","changedValue","parseInt","target","setCellValue","index","getCellValue","type","min","max","Grid","cellsKeys","Array","from","cells","keys","onSetCellValue","cellValue","map","cellsKey","key","isPossibleToSet","matrix","rowPos","columnPos","candidateNum","i","rowBoxStart","colBoxStart","j","solveSudokuArray","array","convertedMatrix","tempArray","length","Number","isInteger","push","console","warn","k","boxSubArray","m","n","sort","a","b","testBoxEl","log","isGivenSudokuValid","solveSudoku","flat","indicesRange","foundIndices","foundI","foundJ","candidate","finished","App","SUDOKU_SIZE","buttonLabel","setButtonLabel","info","setInfo","onClick","fill","sudokuValue","isArray","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.4cb78295.chunk.js","sourcesContent":["import React, { ChangeEvent, useState } from \"react\";\nimport \"./Cell.css\"\ninterface IProps {\n    setCellValue: (a: number | string, b: number) => void\n    index: number\n    getCellValue: number | undefined\n}\n\nfunction Cell(props: IProps) {\n    const [value, setValue] = useState();\n    const checkInput = (e: ChangeEvent<HTMLInputElement>) => {\n        const changedValue = parseInt(e.target.value);\n        // console.warn(props.getCellValue)\n        setValue(changedValue);\n        props.setCellValue(changedValue, props.index);\n        if (changedValue < 1 || changedValue > 9) {\n            setValue(\"\");\n            props.setCellValue(\"\", props.index);\n        }\n    }\n    return (\n        <div className=\"Cell\">\n            <input onChange={checkInput} value={props.getCellValue || value || \"\"} type=\"number\" min=\"1\" max=\"9\"></input>\n        </div>\n    );\n}\n\nexport default Cell;","import React from \"react\";\nimport Cell from \"./Cell\";\nimport \"./Grid.css\";\n\ninterface IProps {\n    cells: Array<number | undefined>\n}\n\nfunction Grid(props: IProps) {\n    const cellsKeys: Array<number> = Array.from(props.cells.keys());\n    const onSetCellValue = (cellValue: number | string, index: number) => {\n        props.cells[index] = typeof cellValue === \"string\" ? 0 : cellValue;\n    }\n    const onGetCellValue = (index: number) => {\n        // console.log(\"onGetCellValue called\", props.cells)\n        return props.cells[index];\n    }\n    return (\n        <div className=\"Grid\">\n            { cellsKeys.map((cellsKey) => <Cell key={cellsKey} setCellValue={onSetCellValue} index={cellsKey} getCellValue={onGetCellValue(cellsKey)}/>) }\n            <div className=\"delimiter-h h1\"/>\n            <div className=\"delimiter-h h2\"/>\n            <div className=\"delimiter-v v1\"/>\n            <div className=\"delimiter-v v2\"/>\n        </div>\n    )\n};\n\nexport default Grid;\n","const MATRIX_SIZE = 9;\ntype Matrix = Array<Array<number>>;\n\nconst isPossibleToSet = (\n    matrix: Matrix,\n    rowPos: number,\n    columnPos: number,\n    candidateNum: number\n): boolean => {\n    // check given row\n    for (let i = 0; i < MATRIX_SIZE; i++) {\n        if (matrix[rowPos][i] === candidateNum) {\n            return false;\n        }\n    }\n\n    // TODO: merge row&column checks\n    // check given column\n    for (let i = 0; i < MATRIX_SIZE; i++) {\n        if (matrix[i][columnPos] === candidateNum) {\n            return false;\n        }\n    }\n\n    // check belonging box\n    const rowBoxStart = rowPos > 2 ? ( rowPos > 5 ? 6 : 3) : 0;\n    const colBoxStart = columnPos > 2 ? ( columnPos > 5 ? 6 : 3) : 0;\n    for (let i = rowBoxStart; i < rowBoxStart + 3; i++) {\n        for (let j = colBoxStart; j < colBoxStart + 3; j++) {\n            if (matrix[i][j] === candidateNum) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n};\n\nexport const isGivenSudokuValid = (matrix: Matrix) => {\n    for (let i = 0; i < MATRIX_SIZE; i++) {\n        for (let j = 0; j < MATRIX_SIZE; j++) {\n            if (matrix[i][j]) {\n                console.warn(\"in if \", matrix[i][j]);\n                // check same row & column\n                for (let k = 0; k < MATRIX_SIZE; k++) {\n                    if (k !== i && matrix[k][j] === matrix[i][j]) {\n                        return false;\n                    }\n                    if (k !== j && matrix[i][k] === matrix[i][j]) {\n                        return false;\n                    }\n                }\n                // check belonging box\n                const rowBoxStart = i > 2 ? ( i > 5 ? 6 : 3) : 0;\n                const colBoxStart = j > 2 ? ( j > 5 ? 6 : 3) : 0;\n                const boxSubArray = [];\n                for (let m = rowBoxStart; m < rowBoxStart + 3; m++) {\n                    for (let n = colBoxStart; n < colBoxStart + 3; n++) {\n                        if (matrix[n][m]) {\n                            boxSubArray.push(matrix[n][m]);\n                        }\n                    }\n                }\n                boxSubArray.sort((a, b) => a - b);\n                let testBoxEl = boxSubArray[0];\n                for (let k = 1; k < boxSubArray.length; k ++) {\n                    console.log(testBoxEl, boxSubArray[k])\n                    if (testBoxEl === boxSubArray[k]) { return false; }\n                    testBoxEl = boxSubArray[k];\n                }\n            }\n        }\n    }\n    return true;\n};\n\nexport const solveSudokuArray = (array: Array<number>) => {\n    let convertedMatrix: Matrix = [];\n    let tempArray: Array<number> = [];\n    for (let i = 0; i < array.length; i++) {\n        if (!Number.isInteger(array[i])) { array[i] = 0; }\n        tempArray.push(array[i]);\n        if ((i + 1) % MATRIX_SIZE === 0) {\n            convertedMatrix.push(tempArray);\n            tempArray = [];\n        }\n    }\n    if (!isGivenSudokuValid(convertedMatrix)) {\n        // console.warn(\"Invalid Sudoku!\", convertedMatrix);\n        return \"Invalid Sudoku!\";\n    }\n    if (solveSudoku(convertedMatrix)) {\n        return convertedMatrix.flat();\n    } else {\n        return \"Not possible to solve this sudoku setup!\";\n    }\n}\n\nconst solveSudoku = (matrix: Matrix): boolean => {\n    const indicesRange = Array.from(Array(MATRIX_SIZE).keys());\n    let foundIndices: Array<number> = [];\n    for (let i of indicesRange) {\n        for (let j of indicesRange) {\n            if (matrix[i][j] === 0) {\n                foundIndices = [i, j];\n                break;\n            }\n        }\n        if (foundIndices.length) {\n            break;\n        }\n    }\n    if (!foundIndices.length) {\n        return true;\n    }\n\n    const [foundI, foundJ] = foundIndices; \n    for (let candidate = 1; candidate <= MATRIX_SIZE; candidate++) {\n        if (isPossibleToSet(matrix, foundI, foundJ, candidate)) {\n            matrix[foundI][foundJ] = candidate;\n            if (solveSudoku(matrix)) {\n                return true;\n            } else {\n                matrix[foundI][foundJ] = 0;\n            } \n        }\n    }\n    return false;\n};\n","import React, { useState } from 'react';\nimport './App.css';\nimport Grid from \"./components/Grid\";\nimport { SUDOKU_SIZE } from \"./utils/consts\";\nimport { solveSudokuArray } from \"./utils/solver\";\n\nlet finished = false;\n\nfunction App() {\n  let cells: Array<number> = Array(SUDOKU_SIZE * 9);\n  const [value, setValue] = useState(cells);\n  const [buttonLabel, setButtonLabel] = useState(\"Solve\");\n  const solveSudoku = () => {\n    console.warn(finished)\n    if (finished) {\n      cells = Array(SUDOKU_SIZE * 9).fill(\"\");\n      setValue(cells);\n      setButtonLabel(\"Solve\");\n      setInfo(\"\");\n      finished = false;\n    } else {\n      console.warn(\"in ELSE\")\n      const sudokuValue: number[] | string = solveSudokuArray(value);\n      if (Array.isArray(sudokuValue)) {\n        setValue(sudokuValue);\n      } else {\n        setInfo(sudokuValue);\n      }\n      setButtonLabel(\"Restart\");\n      finished = true;\n    }\n  };\n  const [info, setInfo] = useState(\"\");\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <h1>SUDOKU Solver</h1>\n      </header>\n  <button className=\"App-button\" onClick={solveSudoku}>{buttonLabel}</button>\n      <Grid cells={value}/>\n      <h2 className=\"App-info\">{info}</h2>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}